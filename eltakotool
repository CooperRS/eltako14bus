#!/usr/bin/env python3

import argparse
import asyncio
import functools
import os
import os.path
import random
import time
import sys
import pickle
from typing import *
import abc
import socket

import aiocoap
import serial.aio

def b2a(rawdata):
    # like binascii.b2a_hex, but directly to unicode for printing, and with nice spacing
    return " ".join("%02x"%b for b in rawdata)

class ParseError(ValueError): """Raised by ESP2Message and similar's .parse() method when data is unexpected"""
class TimeoutError(Exception): """Raised by exchange if the bus timeout is encountered, or a FAM responded with a timeout message."""

class BusInterface(metaclass=abc.ABCMeta):
    async def exchange(self, request, responsetype=None):
        """Send a request and get back a response. The response will be of
        responsetype or (if None) any suitable ESP2Message subclass. If the
        response type fails to parse the response because it is a timeout, a
        TimeoutError will be raised instead of the expected ParseError."""

        response = await self.base_exchange(request)

        if responsetype is None:
            return prettify(ESP2Message.parse(response))

        try:
            return responsetype.parse(response)
        except ParseError:
            try:
                EltakoTimeout.parse(response)
            except ParseError:
                pass
            else:
                raise TimeoutError
            raise

    @abc.abstractmethod
    async def base_exchange(self, request):
        """Exchange function without responsetype bells and whistles, returns
        only a payload.

        Right now, everyone implements this -- if it becomes practical that a
        BusInterface does not, this function here should start raising
        NotImplementedError, and users should fall back to
        exchange().serialize(), or maybe this should provide that here."""

    async def read_mem(self, address) -> Tuple[bytes]:
        """Return the complete memory content of the bus participant with the
        given address, as queried with F1 messages."""

        # FIXME more stringent error handling / message type filtering
        data = []
        for j in range(256):
            response = await self.exchange(EltakoMemoryRequest(address, j), EltakoMessage)
            data.append(response.payload)
        return tuple(data)

class CoAPInterface(BusInterface):
    def __init__(self, context, address):
        self.context = context
        self.address = address

    async def base_exchange(self, request):
        # FIXME this should do more error handling
        coap_request = aiocoap.Message(code=aiocoap.POST, uri=self.address, payload=request.serialize())
        coap_response = await self.context.request(coap_request).response

        return coap_response.payload

    async def read_mem(self, address):
        # FIXME this is not how URIs work
        coap_request = aiocoap.Message(code=aiocoap.GET, uri=self.address.replace('raw', 'memory') + '?addr=%d'%address)
        coap_response = await self.context.request(coap_request).response

        full = coap_response.payload

        row_length = 8
        row_number = 256
        assert len(full) == row_length * row_number

        return tuple(full[i*row_length:(i+1)*row_length] for i in range(row_number))

class ReadaheadMixin:
    """While this technically inherits from BusInterface alone, it is only
    practical in connection with a BusCache because otherwise the obtained data
    is immediately lost again"""

    async def base_exchange(self, request):
        pretty = prettify(request)
        if isinstance(pretty, EltakoMemoryRequest):
            full = await self.read_mem(pretty.address)
            return EltakoMessage(0xf1, pretty.row, full[pretty.row], is_request=False).serialize()

        return await super(ReadaheadMixin, self).base_exchange(request)

class BusCache(BusInterface):
    """Basic store of attributes on the bus that are not expected to change.

    This class takes care of the actual caching logic, but relies on subclasss
    to provide storage."""

    def __init__(self, parent):
        self.parent = parent

    async def base_exchange(self, request):
        pretty = prettify(request)
        key = None
        if isinstance(pretty, EltakoFAMQuery):
            key = 'famquery'
        elif isinstance(pretty, EltakoDiscoveryRequest):
            key = ('discover', pretty.address)
        elif isinstance(pretty, EltakoMemoryRequest):
            key = ('read', pretty.address, pretty.row)

        if key is None: # uncachable
            return await self.parent.base_exchange(request)

        if key not in self:
            try:
                self[key] = await self.parent.base_exchange(request)
            except TimeoutError:
                self[key] = EltakoTimeout().serialize()

        return self[key]

    async def read_mem(self, address):
        key = ('memory', address)
        if key not in self:
            self[key] = await self.parent.read_mem(address)
        return self[key]

class RAMBusCache(dict, BusCache):
    pass

class PickledBusCache(RAMBusCache):
    def __init__(self, parent, filename):
        BusCache.__init__(self, parent)

        self._filename = filename
        if os.path.exists(filename):
            self.update(pickle.load(open(self._filename, 'rb')))

    def __setitem__(self, k, v):
        super(PickledBusCache, self).__setitem__(k, v)

        tmpname = self._filename + '.tmp'
        with open(tmpname, 'wb') as f:
            pickle.dump(dict(self), f)
        os.rename(tmpname, self._filename)

class ReadaheadPickledBusCache(ReadaheadMixin, PickledBusCache):
    pass

def prettify(message):
    classes = [EltakoFAMQuery, EltakoDiscoveryRequest, EltakoDiscoveryReply,
            EltakoMemoryRequest, EltakoTimeout, EltakoMessage]

    for c in classes:
        try: return c.parse(message.serialize())
        except ParseError: pass

    return message

class ESP2Message:
    def __init__(self, body):
        self.body = body

    def serialize(self):
        return b"\xa5\x5a" + self.body + bytes([sum(self.body) % 256])

    @classmethod
    def parse(cls, data):
        if data[:2] != b"\xa5\x5a":
            raise ParseError("No preamble found")
        if len(data) != 14:
            raise ParseError("Invalid message length")

        body = data[2:13]
        if sum(body) % 256 != data[13]:
            raise ParseError("Checksum mismatch")

        return ESP2Message(body)

    def __repr__(self):
        return "<%s %r>"%(type(self).__name__, self.body)

class EltakoMessage(ESP2Message):
    def __init__(self, org, address, payload=b"\0\0\0\0\0\0\0\0", is_request=True):
        self.org = org
        self.address = address
        self.payload = payload
        self.is_request = is_request

    body = property(lambda self: bytes((((5 if self.is_request else 4) << 5) + 11, self.org, *self.payload, self.address)))

    @classmethod
    def parse(cls, data):
        esp2message = super().parse(data)
        try:
            is_request = {(5 << 5) + 11: True, (4 << 5) + 11: False}[esp2message.body[0]]
        except KeyError:
            raise ParseError("Code is neither TCT nor RMT")
        org = esp2message.body[1]
        address = esp2message.body[10]
        payload = esp2message.body[2:10]
        return EltakoMessage(org, address, payload, is_request)

    def __repr__(self):
        return "<%s %s ORG %02x ADDR %02x, %s>"%(type(self).__name__, ["Response", "Request"][self.is_request], self.org, self.address, b2a(self.payload))

class EltakoStaticMessage(EltakoMessage):
    """Base class for any kind of message that has no variance in it at all"""
    def __init__(self):
        pass

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                eltakomessage.payload != cls.payload or eltakomessage.address != cls.address:
            raise ParseError("This is not an EltakoFAMQuery")
        return cls()

    def __repr__(self):
        return "<%s>"%type(self).__name__

class EltakoFAMQuery(EltakoStaticMessage):
    org = 0xff
    is_request = True
    address = 0xff
    payload = b"\0\0\0\0\0\0\0\0"

class EltakoDiscoveryRequest(EltakoMessage):
    org = 0xf0
    is_request = True
    payload = b"\0\0\0\0\0\0\0\0"

    def __init__(self, address):
        self.address = address

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                eltakomessage.payload != cls.payload:
            raise ParseError("This is not an EltakoDiscoveryRequest")
        return cls(eltakomessage.address)

class EltakoDiscoveryReply(EltakoMessage):
    org = 0xf0
    is_request = False
    address = 0

    def __init__(self, reported_address, reported_size, model):
        self.reported_address = reported_address
        self.reported_size = reported_size
        self.model = model

    payload = property(lambda self: bytes((self.reported_address, self.reported_size, 0x7f, 0x08)) + self.model)

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or eltakomessage.address != cls.address:
            raise ParseError("This is not an EltakoDiscoveryReply")
        if eltakomessage.payload[2:4] != b"\x7f\x08":
            print(ParseError("Assumed fixed part 7F 08 not present (found %02x %02x)"%tuple(eltakomessage.payload[2:4])))
            #raise ParseError("Assumed fixed part 7F 08 not present (found %02x %02x)"%tuple(eltakomessage.payload[2:4]))
        reported_address = eltakomessage.payload[0]
        reported_size = eltakomessage.payload[1]
        model = eltakomessage.payload[4:8]
        return EltakoDiscoveryReply(reported_address, reported_size, model)

    def __repr__(self):
        return "<%s address %d size %d, model %s>"%(type(self).__name__, self.reported_address, self.reported_size, b2a(self.model))

class EltakoMemoryRequest(EltakoMessage):
    org = 0xf1
    is_request = True

    @property
    def payload(self):
        return bytes([0] * 7 + [self.row])

    def __init__(self, address, row):
        self.address = address
        self.row = row

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                any(eltakomessage.payload[:7]):
            raise ParseError("This is not an EltakoMemoryRequest")
        return cls(eltakomessage.address, eltakomessage.payload[7])

    def __repr__(self):
        return "<%s address %d row %d>"%(type(self).__name__, self.address, self.row)

class EltakoTimeout(EltakoStaticMessage):
    org = 0xf8
    is_request = False
    payload = b"\0\0\0\0\0\0\0\0"
    address = 0

async def enumerate(bus):
    print("Scanning the bus for devices with addresses...")
    usage_map = [None]
    while len(usage_map) < 255:
        try:
            response = await bus.exchange(EltakoMessage(org=0xf0, address=len(usage_map)), EltakoDiscoveryReply)
        except TimeoutError:
            usage_map.append(False)
        else:
            if len(usage_map) != response.reported_address:
                raise Exception("Wrong discovery reply received. Could there be a FAM on the bus currently enumerating?")
            print("Discovered at %d: Device sized %d, type %s"%(len(usage_map), response.reported_size, b2a(response.model)))
            for i in range(response.reported_size):
                usage_map.append(True)

    print("Bus scan completed.")

    reported = False
    while True:
        try:
            response = await bus.exchange(EltakoMessage(org=0xf0, address=0), EltakoDiscoveryReply)
        except TimeoutError:
            if reported is False:
                print("You may now put a device into LRN mode to automatically assign an address.")
                reported = True
        else:
            print("A device is available in LRN mode (model %s, size %d)."%(b2a(response.model), response.reported_size))
            for i in range(1, 254 - response.reported_size):
                if not any(usage_map[i:i+response.reported_size]):
                    break
            else:
                raise Exception("No suitable free space in usage map")

            usage_map[i:i+response.reported_size] = [True] * response.reported_size
            response = await bus.exchange(EltakoMessage(org=0xf8, address=i), EltakoDiscoveryReply)
            if response.reported_address == 0:
                print("Assigning may not have worked, marking area as dirty and trying again...")
                continue
            assert response.reported_address == i, "Assigning bus number %d resulted in response %r"%(i, response)
            print("The device was assigned bus address %d. You may now put a further device into LRN mode."%i)

async def preread(bus):
    """Given a partial'd exchange function, read once through all addresses and all their memory content"""
    for i in range(255):
        try:
            r = await bus.exchange(EltakoDiscoveryRequest(address=i), EltakoDiscoveryReply)
        except TimeoutError:
            continue

        print("Scanning memory of %d"%i)
        await bus.read_mem(i)
    print("Scanning memory of 255")
    await bus.read_mem(255)

async def run_fakefam(bus, reader, writer, conn_made: Optional[asyncio.Future]=None, conn_end: Optional[asyncio.Future]=None):
    if conn_made:
        conn_made.set_result(None)
    buffered = b""

    while True:
        try:
            buffered += await reader.readexactly(14 - len(buffered))
        except asyncio.streams.IncompleteReadError:
            break
        while len(buffered) >= 14:
            try:
                parsed = ESP2Message.parse(buffered[:14])
            except ParseError:
                buffered = buffered[1:]
            else:
                buffered = buffered[14:]

                start = time.time()
                response = await bus.exchange(parsed, ESP2Message)
                end = time.time()
                print(prettify(parsed), "(%.3fs)"%(end - start), prettify(response))
                writer.write(response.serialize())

    if conn_end:
        conn_end.set_result(None)

async def fakefam(bus, serverdevice):
    # serverdevice will be tested to be a character device, and otherwise
    # opened as a unix or tcp socket depending on whether it contains slashes
    # or colons.
    loop = asyncio.get_event_loop()

    try:
        # reader, writer = await serial.aio.open_serial_connection(serverdevice, baudrate=57600, loop=loop)
        # the above should work as well -- this is a workaround for not-sure-what
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        transport, _ = await serial.aio.create_serial_connection(loop, lambda: protocol, serverdevice, baudrate=57600)
        writer = asyncio.StreamWriter(transport, protocol, reader, loop)
        await run_fakefam(bus, reader, writer)
    except serial.serialutil.SerialException:
        pass
    else:
        def read():
            return os.read(s.fileno(), 1024)
        write = s.write

        q = asyncio.Queue(loop=loop)
        loop.add_reader(s.fileno(), lambda: q.put_nowait(read()))
        return

    conn_end = asyncio.Future()
    if '/' in serverdevice or not ':' in serverdevice:
        conn_made = asyncio.Future()
        await asyncio.start_unix_server(functools.partial(run_fakefam, bus, conn_made=conn_made, conn_end=conn_end), serverdevice, loop=loop)
        await conn_made
        os.unlink(serverdevice)
    else:
        # note that this could run several connections at the same time, which is both great and terrifying
        host, port = serverdevice.split(':', 1)
        await asyncio.start_server(functools.partial(run_fakefam, bus, conn_end=conn_end), host, int(port), loop=loop)
    await conn_end

async def send_raw(bus, data):
    print(prettify(await bus.exchange(ESP2Message(bytes(data)), ESP2Message)))

async def unlock_bus(bus):
    for i in range(5):
        response = await bus.exchange(EltakoMessage(0xff, 0x00), EltakoMessage)
        if response.org == 0xf0:
            print("FAM acknowledged return to regular operation (%s)"%response)
            return
        if response.org != 0xf8:
            print("Unexpected response %r"%response)
    print("Sent some requests, but no acknowledgement from FAM; maybe we're bus master ourselves")

async def show_off(bus, search_term=""):
    print("Sending a lock command onto the bus; its reply should tell us whether there's a FAM in the game.")
    # more correct might be doing this until we get a response from a fam, or until we are sure we're the bus master ourselves
    print(await bus.exchange(EltakoMessage(0xff, 0xff)))

    class BusObject:
        def __init__(self, response):
            self.discovery_response = response
            if self.discovery_response.reported_size != self.size:
                # won't happen with the default size implementation, but another class may give a constant here
                raise ValueError("Unexpected size")
        @property
        def version(self):
            high, low = self.discovery_response.model[2:4]
            return (high >> 4, high & 0xf, low >> 4, low & 0xf0)
        address = property(lambda self: self.discovery_response.reported_address)
        size = property(lambda self: self.discovery_response.reported_size)
        def __repr__(self):
            return "<%s at %d size %d version %s>"%(type(self).__name__, self.address, self.size, self.version)
        async def show_off(self):
            print("Identifying on the bus")
            await bus.exchange(EltakoMessage(0xfd, self.address))
            await asyncio.sleep(3)
    class FUD14(BusObject):
        size = 1
        async def show_off(self):
            await super().show_off()

            print("Querying dimmer state")
            response = await(bus.exchange(EltakoMessage(0xfe, self.address), EltakoMessage))
            # parsing A5-38-08 style data
            assert response.org == 0x07
            # parsing is a little funny here because while it's an RMT, it
            # still behaves like a message with regular payload
            assert response.payload[0] == 0x02
            print("Dimmer value is %d"%response.payload[1]) # it's funny -- the FUD usually reports 'absolute', but then still has its db2 ranging from 0 to 100 instead of 255
            print("Ramping speed is %ds to 100%%"%response.payload[2])
            print("Bits are %s, %s, %s"%(
                ["absolute", "relative"][response.payload[3] & (1 << 2)],
                ["don't store", "store"][response.payload[3] & (1 << 1)],
                ["switch off", "switch on"][response.payload[3] & (1 << 0)],
                ))

            print("Reading out input programming")
            for memory_id in range(12, 128):
                response = await(bus.exchange(EltakoMemoryRequest(self.address, memory_id), EltakoMessage))
                assert response.org == 0xf1
                assert response.address == memory_id
                sender = response.payload[:4]
                if response.payload[5] == 32:
                    dimming = random.randint(0, 100)
                    print("I'e found a programmed universal dimmer state input, sending value %d"%dimming)
                    print(await(bus.exchange(ESP2Message(b"\x0b\x07\x02" + bytes([dimming]) + b"\0\x09" + sender + b"\0"))))

    class FSR14(BusObject):
        size = 1
    class FSR14_2x(BusObject):
        size = 2
    class F4SR14_LED(BusObject):
        size = 4
    class F3Z14D(BusObject):
        size = 3
    class FMZ14(BusObject):
        size = 1
    class FWG14MS(BusObject):
        size = 1
    class FSU14(BusObject):
        size = 8
        async def show_off(self):
            await super().show_off()

            hour = random.randint(0, 23)
            minutes = random.randint(0, 59)
            print("Setting clock to %02d:%02d"%(hour, minutes))
            select_response = await bus.exchange(EltakoMessage(0xf2, self.address))
            if select_response.org != 0xf2:
                print("Selecting the clock went wrong (got %r)"%select_response)
            else:
                write_response = await bus.exchange(EltakoMessage(0xf4, 0x5d, b"\x16\x01\x01\x08" + bytes((((hour // 10) << 4) + (hour % 10), ((minutes // 10) << 4) + (minutes % 10))) + b"\x00\x01"))
                if write_response.org != 0xf4:
                    print("Writing went wrong (got %r)"%write_response)

            await asyncio.sleep(3)

    classes = {
            bytes((0x04, 0x04)): FUD14,
            bytes((0x04, 0x01)): FSR14,
            bytes((0x04, 0x02)): FSR14_2x,
            bytes((0x04, 0x09)): F4SR14_LED,
            bytes((0x04, 0x0e)): FMZ14,
            bytes((0x04, 0x1a)): FWG14MS,
            bytes((0x04, 0x67)): F3Z14D,
            bytes((0x07, 0x14)): FSU14,
            }
    devices = []

    print("Scanning the bus for devices with addresses...")

    try:
        search_term_int = int(search_term)
    except ValueError:
        scan = range(1, 255)
    else:
        scan = [search_term_int]
        search_term = ""
    for i in scan: # FIXME this is just for faster testing
        try:
            response = await bus.exchange(EltakoMessage(org=0xf0, address=i), EltakoDiscoveryReply)
        except TimeoutError:
            continue
        else:
            assert i == response.reported_address
            for prefix, c in sorted(classes.items(), key=lambda p: len(p), reverse=True):
                if response.model.startswith(prefix):
                    if not search_term or search_term.lower() in c.__name__.lower():
                        dev = c(response)
                        devices.append(dev)
                        print("Discovered %r"%dev)
                    else:
                        print("Ignoring discovered %s at %d"%(c.__name__, i))
                    break
            else:
                print("Ignoring unknown device at %d sized %d, type %s"%(i, response.reported_size, b2a(response.model)))

    if not devices:
        print("No matching devices found.")
        print(await bus.exchange(EltakoMessage(0xff, 0x00)))
        return

    print("Now let's see what the devices can do:")

    while True:
        await asyncio.sleep(2)
        for d in devices:
            print("Playing with %r"%d)
            await d.show_off()

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--rawuri", help="URI at which a raw ESP2 resource is exposed")
    p.add_argument("--cachefile", help="File to cache responses at")
    p.add_argument("--preread", help="Enumerate bus and read devices' memory before executing the command", action='store_true')
    subp = p.add_subparsers(metavar="command", dest="command")

    p_enumerate = subp.add_parser("enumerate", help="Explore the bus")
    p_fakefam = subp.add_parser("fakefam", help="Act like a FAM14")
    p_fakefam.add_argument("device", help="Serial device to listen on for bus commands")

    p_send4bs = subp.add_parser("send_raw", help="Send a raw telegram (h_seq/len, org, data, id, status), with bytes as individual hex arguments")
    base16 = functools.partial(int, base=16)
    p_send4bs.add_argument("data", type=base16, nargs=11)

    subp.add_parser("unlock_bus", help="Release the FAM to normal operation")

    p_showoff = subp.add_parser("show_off", help="Run a demo of what is currently known of the bus")
    p_showoff.add_argument("searchterm", nargs="?", default="", help="Bus address or type name to focus on")

    opts = p.parse_args()

    if opts.command is None:
        raise p.error("A command is required.")

    if opts.rawuri is None:
        raise p.error("Autodiscovery is not yet implemented, please give --rawuri argument..")

    loop = asyncio.get_event_loop()
    context = loop.run_until_complete(aiocoap.Context.create_client_context())

    bus = CoAPInterface(context, opts.rawuri)
    if opts.cachefile:
        bus = ReadaheadPickledBusCache(bus, opts.cachefile)

    if opts.preread:
        if not opts.cachefile:
            print("Warning: Without caching, prereading is not much good.")
        print("Prereading bus...")
        loop.run_until_complete(preread(bus))
        print("done.")

    if opts.command == "enumerate":
        loop.run_until_complete(enumerate(bus))
    elif opts.command == "fakefam":
        loop.run_until_complete(fakefam(bus, opts.device))
    elif opts.command == "send_raw":
        loop.run_until_complete(send_raw(bus, opts.data))
    elif opts.command == "unlock_bus":
        loop.run_until_complete(unlock_bus(bus))
    elif opts.command == "show_off":
        loop.run_until_complete(show_off(bus, opts.searchterm))
    else:
        raise RuntimeError("Additional command declared but not implemented.")

if __name__ == "__main__":
    main()
