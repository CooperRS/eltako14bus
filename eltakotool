#!/usr/bin/env python3

import argparse
import asyncio
import functools
import os
import random
import time
import sys
import pickle
from typing import *
import abc
import socket
from pathlib import Path

import aiocoap
import serial.aio
import xdg.BaseDirectory

def b2a(rawdata):
    # like binascii.b2a_hex, but directly to unicode for printing, and with nice spacing
    return " ".join("%02x"%b for b in rawdata)

class ParseError(ValueError): """Raised by ESP2Message and similar's .parse() method when data is unexpected"""
class TimeoutError(Exception): """Raised by exchange if the bus timeout is encountered, or a FAM responded with a timeout message."""

class BusInterface(metaclass=abc.ABCMeta):
    async def exchange(self, request, responsetype=None):
        """Send a request and get back a response. The response will be of
        responsetype or (if None) any suitable ESP2Message subclass. If the
        response type fails to parse the response because it is a timeout, a
        TimeoutError will be raised instead of the expected ParseError."""

        response = await self.base_exchange(request)

        if responsetype is None:
            return prettify(ESP2Message.parse(response))

        try:
            return responsetype.parse(response)
        except ParseError:
            try:
                EltakoTimeout.parse(response)
            except ParseError:
                pass
            else:
                raise TimeoutError
            raise

    @abc.abstractmethod
    async def base_exchange(self, request):
        """Exchange function without responsetype bells and whistles, returns
        only a payload.

        Right now, everyone implements this -- if it becomes practical that a
        BusInterface does not, this function here should start raising
        NotImplementedError, and users should fall back to
        exchange().serialize(), or maybe this should provide that here."""

    async def read_mem(self, address) -> Tuple[bytes]:
        """Return the complete memory content of the bus participant with the
        given address, as queried with F1 messages."""

        # FIXME more stringent error handling / message type filtering
        data = []
        for j in range(256):
            response = await self.exchange(EltakoMemoryRequest(address, j), EltakoMessage)
            data.append(response.payload)
        return tuple(data)

class CoAPInterface(BusInterface):
    def __init__(self, context, address):
        self.context = context
        self.address = address

    async def base_exchange(self, request):
        # FIXME this should do more error handling
        coap_request = aiocoap.Message(code=aiocoap.POST, uri=self.address, payload=request.serialize())
        coap_response = await self.context.request(coap_request).response

        return coap_response.payload

    async def read_mem(self, address):
        # FIXME this is not how URIs work
        coap_request = aiocoap.Message(code=aiocoap.GET, uri=self.address.replace('raw', 'memory') + '?addr=%d'%address)
        coap_response = await self.context.request(coap_request).response

        full = coap_response.payload

        row_length = 8
        row_number = 256
        assert len(full) == row_length * row_number

        return tuple(full[i*row_length:(i+1)*row_length] for i in range(row_number))

class ReadaheadMixin:
    """While this technically inherits from BusInterface alone, it is only
    practical in connection with a BusCache because otherwise the obtained data
    is immediately lost again"""

    async def base_exchange(self, request):
        pretty = prettify(request)
        if isinstance(pretty, EltakoMemoryRequest):
            full = await self.read_mem(pretty.address)
            return EltakoMessage(0xf1, pretty.row, full[pretty.row], is_request=False).serialize()

        return await super(ReadaheadMixin, self).base_exchange(request)

# this approach won't work exactly like that, because memory can both be
# written in full or line-wise from PCT; furthermore, there are too many
# timeouts around yet, so there is probably something else fishy.
#
# a better approach would spool all writes and flush them timeout-based, or
# before the next incompatible write comes along.
#
#class WriteDelayer(BusInterface):
#    def __init__(self, *args, **kwargs):
#        super(WriteDelayer, self).__init__(*args, **kwargs)
#        self.spool = []
#
#    async def base_exchange(self, request):
#        pretty = prettify(request)
#        if pretty.org == 0xf2 or pretty.org == 0xf4:
#            print("postponing write operation %s"%request)
#            if pretty.org == 0xf4 and pretty.address == 0x7f:
#                print("Flushing out the write operations now")
#                retries = 3
#                while self.spool:
#                    await asyncio.sleep(0.5)
#                    next_request = self.spool[0]
#                    response = prettify(ESP2Message.parse(await super(WriteDelayer, self).base_exchange(next_request)))
#                    print("%s - %s"%(prettify(next_request), response))
#                    if isinstance(response, EltakoTimeout):
#                        if retries:
#                            retries -= 1
#                            continue
#                        else:
#                            raise Exception("Too many timeouts in write sequence")
#                    else:
#                        self.spool.pop(0)
#                        retries = 3
#                response = await super(WriteDelayer, self).base_exchange(request)
#                print("Flushing complete; you can probably ignore the error the flashing software gave you")
#                return response
#            else:
#                self.spool.append(request)
#
#            return EltakoMessage(pretty.org, pretty.address, pretty.payload, not pretty.is_request).serialize()
#        else:
#            return await super(WriteDelayer, self).base_exchange(request)

class BusCache(BusInterface):
    """Basic store of attributes on the bus that are not expected to change.

    This class takes care of the actual caching logic, but relies on subclasss
    to provide storage.

    The whole locking area is handled as follows: As long as the bus is not
    locked (and it is assumed that the bus is not locked initially), no cached
    data is served, and no responses are cached, due to the assumption that bus
    communication is too erratic then. Only when a successful bus lock is
    obtained, caching is started, and cache responses are handed out.
    Subsequent lock (and even unlock) commands are not sent to the bus, but
    served from memory (as the response to an unlock was always observed to be
    the same as to a lock)."""

    def __init__(self, parent):
        self.parent = parent

        self.is_locked = False

    async def base_exchange(self, request):
        pretty = prettify(request)

        if not self.is_locked:
            response = await self.parent.base_exchange(request)

            try:
                pretty_response = EltakoDiscoveryReply.parse(response)
            except ParseError:
                pass
            else:
                if isinstance(pretty, EltakoBusLock) and isinstance(pretty_response, EltakoDiscoveryReply) and pretty_response.address == 0:
                    self.is_locked = True
                    self['fam_reply'] = response

            return response

        if pretty.org == 0xf2:
            # writing prepared -- we better wipe the cache for that
            self.pop(('memory', pretty.address), None)
            for i in range(256):
                self.pop(('read', pretty.address, i), None)

        key = None
        if isinstance(pretty, EltakoBusLock) or isinstance(pretty, EltakoBusUnlock):
            return self['fam_reply']
        if isinstance(pretty, EltakoDiscoveryRequest):
            key = ('discover', pretty.address)
        elif isinstance(pretty, EltakoMemoryRequest):
            key = ('read', pretty.address, pretty.row)

        if key is None: # uncachable
            return await self.parent.base_exchange(request)

        if key not in self:
            try:
                self[key] = await self.parent.base_exchange(request)
            except TimeoutError:
                self[key] = EltakoTimeout().serialize()

        return self[key]

    async def read_mem(self, address):
        key = ('memory', address)
        if key not in self:
            self[key] = await self.parent.read_mem(address)
        return self[key]

class RAMBusCache(dict, BusCache):
    pass

class PickledBusCache(RAMBusCache):
    def __init__(self, parent, filename):
        BusCache.__init__(self, parent)

        self._filename = filename
        if filename.exists():
            self.update(pickle.load(self._filename.open('rb')))

    def __setitem__(self, k, v):
        super(PickledBusCache, self).__setitem__(k, v)

        tmpname = self._filename.with_suffix(".tmp")
        with tmpname.open('wb') as f:
            pickle.dump(dict(self), f)
        tmpname.rename(self._filename)

class ReadaheadPickledBusCache(ReadaheadMixin, PickledBusCache):
    pass

def prettify(message):
    classes = [EltakoBusLock, EltakoBusUnlock, EltakoDiscoveryRequest, EltakoDiscoveryReply,
            EltakoMemoryRequest, EltakoTimeout, EltakoMessage]

    for c in classes:
        try: return c.parse(message.serialize())
        except ParseError: pass

    return message

class ESP2Message:
    def __init__(self, body):
        self.body = body

    def serialize(self):
        return b"\xa5\x5a" + self.body + bytes([sum(self.body) % 256])

    @classmethod
    def parse(cls, data):
        if data[:2] != b"\xa5\x5a":
            raise ParseError("No preamble found")
        if len(data) != 14:
            raise ParseError("Invalid message length")

        body = data[2:13]
        if sum(body) % 256 != data[13]:
            raise ParseError("Checksum mismatch")

        return ESP2Message(body)

    def __repr__(self):
        return "<%s %r>"%(type(self).__name__, self.body)

class EltakoMessage(ESP2Message):
    def __init__(self, org, address, payload=b"\0\0\0\0\0\0\0\0", is_request=True):
        self.org = org
        self.address = address
        self.payload = payload
        self.is_request = is_request

    body = property(lambda self: bytes((((5 if self.is_request else 4) << 5) + 11, self.org, *self.payload, self.address)))

    @classmethod
    def parse(cls, data):
        esp2message = super().parse(data)
        try:
            is_request = {(5 << 5) + 11: True, (4 << 5) + 11: False}[esp2message.body[0]]
        except KeyError:
            raise ParseError("Code is neither TCT nor RMT")
        org = esp2message.body[1]
        address = esp2message.body[10]
        payload = esp2message.body[2:10]
        return EltakoMessage(org, address, payload, is_request)

    def __repr__(self):
        return "<%s %s ORG %02x ADDR %02x, %s>"%(type(self).__name__, ["Response", "Request"][self.is_request], self.org, self.address, b2a(self.payload))

class EltakoStaticMessage(EltakoMessage):
    """Base class for any kind of message that has no variance in it at all"""
    def __init__(self):
        pass

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                eltakomessage.payload != cls.payload or eltakomessage.address != cls.address:
            raise ParseError("This is not an %s"%(cls.__name__,))
        return cls()

    def __repr__(self):
        return "<%s>"%type(self).__name__

class EltakoBusLock(EltakoStaticMessage):
    org = 0xff
    is_request = True
    address = 0xff
    payload = b"\0\0\0\0\0\0\0\0"

class EltakoBusUnlock(EltakoStaticMessage):
    org = 0xff
    is_request = True
    address = 0x00
    payload = b"\0\0\0\0\0\0\0\0"

class EltakoDiscoveryRequest(EltakoMessage):
    org = 0xf0
    is_request = True
    payload = b"\0\0\0\0\0\0\0\0"

    def __init__(self, address):
        self.address = address

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                eltakomessage.payload != cls.payload:
            raise ParseError("This is not an EltakoDiscoveryRequest")
        return cls(eltakomessage.address)

class EltakoDiscoveryReply(EltakoMessage):
    org = 0xf0
    is_request = False
    address = 0

    def __init__(self, reported_address, reported_size, model):
        self.reported_address = reported_address
        self.reported_size = reported_size
        self.model = model

    payload = property(lambda self: bytes((self.reported_address, self.reported_size, 0x7f, 0x08)) + self.model)

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or eltakomessage.address != cls.address:
            raise ParseError("This is not an EltakoDiscoveryReply")
        if eltakomessage.payload[2:4] != b"\x7f\x08":
            print(ParseError("Assumed fixed part 7F 08 not present (found %02x %02x)"%tuple(eltakomessage.payload[2:4])))
            #raise ParseError("Assumed fixed part 7F 08 not present (found %02x %02x)"%tuple(eltakomessage.payload[2:4]))
        reported_address = eltakomessage.payload[0]
        reported_size = eltakomessage.payload[1]
        model = eltakomessage.payload[4:8]
        return EltakoDiscoveryReply(reported_address, reported_size, model)

    def __repr__(self):
        return "<%s address %d size %d, model %s>"%(type(self).__name__, self.reported_address, self.reported_size, b2a(self.model))

class EltakoMemoryRequest(EltakoMessage):
    org = 0xf1
    is_request = True

    @property
    def payload(self):
        return bytes([0] * 7 + [self.row])

    def __init__(self, address, row):
        self.address = address
        self.row = row

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                any(eltakomessage.payload[:7]):
            raise ParseError("This is not an EltakoMemoryRequest")
        return cls(eltakomessage.address, eltakomessage.payload[7])

    def __repr__(self):
        return "<%s address %d row %d>"%(type(self).__name__, self.address, self.row)

class EltakoTimeout(EltakoStaticMessage):
    org = 0xf8
    is_request = False
    payload = b"\0\0\0\0\0\0\0\0"
    address = 0

async def enumerate(bus):
    print("Scanning the bus for devices with addresses...")
    usage_map = [None]
    while len(usage_map) < 256:
        try:
            response = await bus.exchange(EltakoDiscoveryRequest(address=len(usage_map)), EltakoDiscoveryReply)
        except TimeoutError:
            usage_map.append(False)
        else:
            if len(usage_map) != response.reported_address:
                raise Exception("Wrong discovery reply received. Could there be a FAM on the bus currently enumerating?")
            print("Discovered at %d: Device sized %d, type %s"%(len(usage_map), response.reported_size, b2a(response.model)))
            for i in range(response.reported_size):
                usage_map.append(True)

    print("Bus scan completed.")

    reported = False
    while True:
        try:
            response = await bus.exchange(EltakoDiscoveryRequest(address=0), EltakoDiscoveryReply)
        except TimeoutError:
            if reported is False:
                print("You may now put a device into LRN mode to automatically assign an address.")
                reported = True
        else:
            print("A device is available in LRN mode (model %s, size %d)."%(b2a(response.model), response.reported_size))
            for i in range(1, 254 - response.reported_size):
                if not any(usage_map[i:i+response.reported_size]):
                    break
            else:
                raise Exception("No suitable free space in usage map")

            usage_map[i:i+response.reported_size] = [True] * response.reported_size
            response = await bus.exchange(EltakoMessage(org=0xf8, address=i), EltakoDiscoveryReply)
            if response.reported_address == 0:
                print("Assigning may not have worked, marking area as dirty and trying again...")
                continue
            assert response.reported_address == i, "Assigning bus number %d resulted in response %r"%(i, response)
            print("The device was assigned bus address %d. You may now put a further device into LRN mode."%i)

async def preread(bus):
    """Given a partial'd exchange function, read once through all addresses and all their memory content"""

    print("Locking bus for prereading")
    await lock_bus(bus)
    for i in range(256):
        try:
            r = await bus.exchange(EltakoDiscoveryRequest(address=i), EltakoDiscoveryReply)
        except TimeoutError:
            continue

        print("Scanning memory of %d"%i)
        await bus.read_mem(i)
    print("Unlocking bus after prereading")
    await unlock_bus(bus)

async def run_fakefam(bus, reader, writer, conn_made: Optional[asyncio.Future]=None, conn_end: Optional[asyncio.Future]=None):
    if conn_made:
        conn_made.set_result(None)
    buffered = b""

    while True:
        try:
            buffered += await reader.readexactly(14 - len(buffered))
        except asyncio.streams.IncompleteReadError:
            break
        while len(buffered) >= 14:
            try:
                parsed = ESP2Message.parse(buffered[:14])
            except ParseError:
                buffered = buffered[1:]
            else:
                buffered = buffered[14:]

                start = time.time()
                response = await bus.exchange(parsed, ESP2Message)
                end = time.time()
                print(prettify(parsed), "(%.3fs)"%(end - start), prettify(response))
                writer.write(response.serialize())

    if conn_end:
        conn_end.set_result(None)

async def fakefam(bus, serverdevice):
    # serverdevice will be tested to be a character device, and otherwise
    # opened as a unix or tcp socket depending on whether it contains slashes
    # or colons.
    loop = asyncio.get_event_loop()

    try:
        # reader, writer = await serial.aio.open_serial_connection(serverdevice, baudrate=57600, loop=loop)
        # the above should work as well -- this is a workaround for not-sure-what
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        transport, _ = await serial.aio.create_serial_connection(loop, lambda: protocol, serverdevice, baudrate=57600)
        writer = asyncio.StreamWriter(transport, protocol, reader, loop)
        await run_fakefam(bus, reader, writer)
    except serial.serialutil.SerialException:
        pass
    else:
        def read():
            return os.read(s.fileno(), 1024)
        write = s.write

        q = asyncio.Queue(loop=loop)
        loop.add_reader(s.fileno(), lambda: q.put_nowait(read()))
        return

    conn_end = asyncio.Future()
    if '/' in serverdevice or not ':' in serverdevice:
        conn_made = asyncio.Future()
        await asyncio.start_unix_server(functools.partial(run_fakefam, bus, conn_made=conn_made, conn_end=conn_end), serverdevice, loop=loop)
        await conn_made
        os.unlink(serverdevice)
    else:
        # note that this could run several connections at the same time, which is both great and terrifying
        host, port = serverdevice.split(':', 1)
        await asyncio.start_server(functools.partial(run_fakefam, bus, conn_end=conn_end), host, int(port), loop=loop)
    await conn_end

async def send_raw(bus, data):
    print(prettify(await bus.exchange(ESP2Message(bytes(data)), ESP2Message)))

async def lock_bus(bus):
    for i in range(10):
        try:
            response = await bus.exchange(EltakoBusLock(), EltakoMessage)
        except TimeoutError:
            continue
        if response.org == 0xf0:
            print("FAM acknowledged lock after %d try(s)."%(i+1))
            return
        else:
            print("Unexpected message: %s"%response)
    print("Sent some requests, but no acknowledgement from FAM")

async def unlock_bus(bus):
    # probably we don't need to repeat that at all
    for i in range(5):
        response = await bus.exchange(EltakoBusUnlock(), EltakoMessage)
        if response.org == 0xf0:
            print("FAM acknowledged return to regular operation (%s)"%response)
            return
        if response.org != 0xf8:
            print("Unexpected response %r"%response)
    print("Sent some requests, but no acknowledgement from FAM; maybe we're bus master ourselves")

async def show_off(bus, search_term=""):
    print("Sending a lock command onto the bus; its reply should tell us whether there's a FAM in the game.")
    # more correct might be doing this until we get a response from a fam, or until we are sure we're the bus master ourselves
    print(await bus.exchange(EltakoMessage(0xff, 0xff)))

    class BusObject:
        def __init__(self, response):
            self.discovery_response = response
            if self.discovery_response.reported_size != self.size:
                # won't happen with the default size implementation, but another class may give a constant here
                raise ValueError("Unexpected size")
        @property
        def version(self):
            high, low = self.discovery_response.model[2:4]
            return (high >> 4, high & 0xf, low >> 4, low & 0xf0)
        address = property(lambda self: self.discovery_response.reported_address)
        size = property(lambda self: self.discovery_response.reported_size)
        def __repr__(self):
            return "<%s at %d size %d version %s>"%(type(self).__name__, self.address, self.size, self.version)
        async def show_off(self):
            print("Identifying on the bus")
            await bus.exchange(EltakoMessage(0xfd, self.address))
            await asyncio.sleep(3)
    class FUD14(BusObject):
        size = 1
        async def show_off(self):
            await super().show_off()

            print("Querying dimmer state")
            response = await(bus.exchange(EltakoMessage(0xfe, self.address), EltakoMessage))
            # parsing A5-38-08 style data
            assert response.org == 0x07
            # parsing is a little funny here because while it's an RMT, it
            # still behaves like a message with regular payload
            assert response.payload[0] == 0x02
            print("Dimmer value is %d"%response.payload[1]) # it's funny -- the FUD usually reports 'absolute', but then still has its db2 ranging from 0 to 100 instead of 255
            print("Ramping speed is %ds to 100%%"%response.payload[2])
            print("Bits are %s, %s, %s"%(
                ["absolute", "relative"][response.payload[3] & (1 << 2)],
                ["don't store", "store"][response.payload[3] & (1 << 1)],
                ["switch off", "switch on"][response.payload[3] & (1 << 0)],
                ))

            print("Reading out input programming")
            for memory_id in range(12, 128):
                response = await(bus.exchange(EltakoMemoryRequest(self.address, memory_id), EltakoMessage))
                assert response.org == 0xf1
                assert response.address == memory_id
                sender = response.payload[:4]
                if response.payload[5] == 32:
                    dimming = random.randint(0, 100)
                    print("I'e found a programmed universal dimmer state input, sending value %d"%dimming)
                    print(await(bus.exchange(ESP2Message(b"\x0b\x07\x02" + bytes([dimming]) + b"\0\x09" + sender + b"\0"))))

    class FSR14(BusObject):
        size = 1
    class FSR14_2x(BusObject):
        size = 2
    class F4SR14_LED(BusObject):
        size = 4
    class F3Z14D(BusObject):
        size = 3
    class FMZ14(BusObject):
        size = 1
    class FWG14MS(BusObject):
        size = 1
    class FSU14(BusObject):
        size = 8
        async def show_off(self):
            await super().show_off()

            hour = random.randint(0, 23)
            minutes = random.randint(0, 59)
            print("Setting clock to %02d:%02d"%(hour, minutes))
            select_response = await bus.exchange(EltakoMessage(0xf2, self.address))
            if select_response.org != 0xf2:
                print("Selecting the clock went wrong (got %r)"%select_response)
            else:
                write_response = await bus.exchange(EltakoMessage(0xf4, 0x5d, b"\x16\x01\x01\x08" + bytes((((hour // 10) << 4) + (hour % 10), ((minutes // 10) << 4) + (minutes % 10))) + b"\x00\x01"))
                if write_response.org != 0xf4:
                    print("Writing went wrong (got %r)"%write_response)

            await asyncio.sleep(3)

    classes = {
            bytes((0x04, 0x04)): FUD14,
            bytes((0x04, 0x01)): FSR14,
            bytes((0x04, 0x02)): FSR14_2x,
            bytes((0x04, 0x09)): F4SR14_LED,
            bytes((0x04, 0x0e)): FMZ14,
            bytes((0x04, 0x1a)): FWG14MS,
            bytes((0x04, 0x67)): F3Z14D,
            bytes((0x07, 0x14)): FSU14,
            }
    devices = []

    print("Scanning the bus for devices with addresses...")

    try:
        search_term_int = int(search_term)
    except ValueError:
        scan = range(1, 255)
    else:
        scan = [search_term_int]
        search_term = ""
    for i in scan: # FIXME this is just for faster testing
        try:
            response = await bus.exchange(EltakoMessage(org=0xf0, address=i), EltakoDiscoveryReply)
        except TimeoutError:
            continue
        else:
            assert i == response.reported_address
            for prefix, c in sorted(classes.items(), key=lambda p: len(p), reverse=True):
                if response.model.startswith(prefix):
                    if not search_term or search_term.lower() in c.__name__.lower():
                        dev = c(response)
                        devices.append(dev)
                        print("Discovered %r"%dev)
                    else:
                        print("Ignoring discovered %s at %d"%(c.__name__, i))
                    break
            else:
                print("Ignoring unknown device at %d sized %d, type %s"%(i, response.reported_size, b2a(response.model)))

    if not devices:
        print("No matching devices found.")
        print(await bus.exchange(EltakoMessage(0xff, 0x00)))
        return

    print("Now let's see what the devices can do:")

    while True:
        await asyncio.sleep(2)
        for d in devices:
            print("Playing with %r"%d)
            await d.show_off()

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--rawuri", help="URI at which a raw ESP2 resource is exposed")
    p.add_argument("--cache", help="Store cachable responses locally", action='store_true')
    p.add_argument("--cachefile", help="File to cache responses at", type=Path)
    p.add_argument("--preread", help="Enumerate bus and read devices' memory before executing the command", action='store_true')
    subp = p.add_subparsers(metavar="command", dest="command")

    p_enumerate = subp.add_parser("enumerate", help="Explore the bus")
    p_fakefam = subp.add_parser("fakefam", help="Act like a FAM14")
    p_fakefam.add_argument("device", help="Serial device to listen on for bus commands")

    p_send4bs = subp.add_parser("send_raw", help="Send a raw telegram (h_seq/len, org, data, id, status), with bytes as individual hex arguments")
    base16 = functools.partial(int, base=16)
    p_send4bs.add_argument("data", type=base16, nargs=11)

    p_eval = subp.add_parser("eval", help="Display the response to a single message object passed as a Python expression")
    p_eval.add_argument("expr")

    subp.add_parser("lock_bus", help="Lock the bus")
    subp.add_parser("unlock_bus", help="Release the FAM to normal operation")

    p_showoff = subp.add_parser("show_off", help="Run a demo of what is currently known of the bus")
    p_showoff.add_argument("searchterm", nargs="?", default="", help="Bus address or type name to focus on")

    opts = p.parse_args()

    if opts.command is None:
        raise p.error("A command is required.")

    if opts.rawuri is None:
        raise p.error("Autodiscovery is not yet implemented, please give --rawuri argument..")

    loop = asyncio.get_event_loop()
    context = loop.run_until_complete(aiocoap.Context.create_client_context())

    bus = CoAPInterface(context, opts.rawuri)
    if opts.cache:
        cachefile = opts.cachefile or Path(xdg.BaseDirectory.save_cache_path("eltakotool")) / opts.rawuri.replace('/', '-')
        bus = ReadaheadPickledBusCache(bus, cachefile)

    if opts.preread:
        if not opts.cache:
            print("Warning: Without caching, prereading is not much good.")
        print("Prereading bus...")
        loop.run_until_complete(preread(bus))
        print("done.")

    if opts.command == "enumerate":
        loop.run_until_complete(enumerate(bus))
    elif opts.command == "fakefam":
        loop.run_until_complete(fakefam(bus, opts.device))
    elif opts.command == "send_raw":
        loop.run_until_complete(send_raw(bus, opts.data))
    elif opts.command == "eval":
        print(loop.run_until_complete(bus.exchange(eval(opts.expr))))
    elif opts.command == "lock_bus":
        loop.run_until_complete(lock_bus(bus))
    elif opts.command == "unlock_bus":
        loop.run_until_complete(unlock_bus(bus))
    elif opts.command == "show_off":
        loop.run_until_complete(show_off(bus, opts.searchterm))
    else:
        raise RuntimeError("Additional command declared but not implemented.")

if __name__ == "__main__":
    main()
