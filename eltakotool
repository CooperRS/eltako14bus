#!/usr/bin/env python3

import argparse
import asyncio
import functools
import os
import random
import time
import sys
import pickle
from typing import *
import abc
import socket
from pathlib import Path
import binascii
from collections import defaultdict, namedtuple

import yaml
import aiocoap
import serial_asyncio
import xdg.BaseDirectory

def b2a(rawdata):
    # like binascii.b2a_hex, but directly to unicode for printing, and with nice spacing
    return " ".join("%02x"%b for b in rawdata)

class ParseError(ValueError): """Raised by ESP2Message and similar's .parse() method when data is unexpected"""
class WriteError(Exception): """Raised when a write prcess does not give the expected responses"""
class TimeoutError(Exception): """Raised by exchange if the bus timeout is encountered, or a FAM responded with a timeout message."""


class BusInterface(metaclass=abc.ABCMeta):
    async def exchange(self, request, responsetype=None):
        """Send a request and get back a response. The response will be of
        responsetype or (if None) any suitable ESP2Message subclass. If the
        response type fails to parse the response because it is a timeout, a
        TimeoutError will be raised instead of the expected ParseError.

        The default implementation defers to base_exchange, but drivers are
        invited to implement exchange in full if they can."""

        response = await self.base_exchange(request)

        if responsetype is None:
            return prettify(ESP2Message.parse(response))

        try:
            return responsetype.parse(response)
        except ParseError:
            try:
                EltakoTimeout.parse(response)
            except ParseError:
                pass
            else:
                raise TimeoutError
            raise

    @abc.abstractmethod
    async def base_exchange(self, request):
        """Exchange function without responsetype bells and whistles, returns
        only the first resulting payload.

        Right now, everyone implements this -- if it becomes practical that a
        BusInterface does not, this function here should start raising
        NotImplementedError, and users should fall back to
        exchange().serialize(), or maybe this should provide that here."""

    async def read_mem(self, address) -> Tuple[bytes]:
        """Return the complete memory content of the bus participant with the
        given address, as queried with F1 messages."""

        # FIXME more stringent error handling / message type filtering
        data = []
        for j in range(256):
            response = await self.exchange(EltakoMemoryRequest(address, j), EltakoMessage)
            data.append(response.payload)
        return tuple(data)

class CoAPInterface(BusInterface):
    def __init__(self, context, address):
        self.context = context
        self.address = address

    async def base_exchange(self, request):
        coap_request = aiocoap.Message(code=aiocoap.POST, uri=self.address, payload=request.serialize())
        coap_response = await self.context.request(coap_request).response

        if coap_response.code != aiocoap.CONTENT:
            raise Exception("Unsuccessful response: %s %s"%(coap_response, coap_response.payload))

        return coap_response.payload

    async def read_mem(self, address):
        # FIXME this is not how URIs work
        coap_request = aiocoap.Message(code=aiocoap.GET, uri=self.address.replace('raw', 'memory') + '?addr=%d'%address)
        coap_response = await self.context.request(coap_request).response

        full = coap_response.payload

        row_length = 8
        row_number = 256
        assert len(full) == row_length * row_number

        return tuple(full[i*row_length:(i+1)*row_length] for i in range(row_number))

class RS485SerialInterface(BusInterface):
    def __init__(self, filename):
        self._filename = filename

        self.received = asyncio.Queue()
        self._hook = None

    async def run(self, loop, *, conn_made=None):
        self._loop = loop
        reader, self._writer = await serial_asyncio.open_serial_connection(url=self._filename, baudrate=57600, loop=loop)

        if conn_made is not None:
            conn_made.set_result(None)

        buffered = b""

        while True:
            try:
                buffered += await reader.readexactly(14 - len(buffered))
            except asyncio.streams.IncompleteReadError:
                # TBD: determine whether this shows up somewhere, and develop a signaling strategy
                raise
            while len(buffered) >= 14:
                try:
                    parsed = ESP2Message.parse(buffered[:14])
                except ParseError:
                    buffered = buffered[1:]
                else:
                    buffered = buffered[14:]

                    if self._hook is not None and self._hook(parsed):
                        continue # swallowed by the hook
                    await self.received.put(parsed)

    async def exchange(self, request, responsetype=None):
        """Send a request and return a response depending on responsetype as
        BusInterface.exchange does.

        Unlike that basic imlementation, this accepts messages inbetween that
        are not of the specified type, and passes them on to the receive queue
        if they don't match."""

        if self._hook is not None:
            raise RuntimeError("exchange is not reentrant, please serialize your access to the bus yourself.")

        match = asyncio.Future()

        def hook(message):
            if responsetype is None:
                match.set_result(prettify(message))
                self._hook = None
                return True
            else:
                try:
                    parsed = responsetype.parse(message.serialize())
                except ParseError:
                    try:
                        EltakoTimeout.parse(message.serialize())
                    except ParseError:
                        pass
                    else:
                        match.set_exception(TimeoutError)
                        self._hook = None
                        return True
                    return False
                else:
                    match.set_result(parsed)
                    self._hook = None
                    return True

        try:
            self._hook = hook

            self._writer.write(request.serialize())
            try:
                # FIXME this timeout is rather arbitrary
                return await asyncio.wait_for(match, timeout=1, loop=self._loop)
            except asyncio.TimeoutError:
                if responsetype is EltakoTimeout:
                    return EltakoTimeout()
                else:
                    raise TimeoutError
        finally:
            self._hook = None

    base_exchange = None

class ReadaheadMixin:
    """While this technically inherits from BusInterface alone, it is only
    practical in connection with a BusCache because otherwise the obtained data
    is immediately lost again"""

    async def base_exchange(self, request):
        pretty = prettify(request)
        if isinstance(pretty, EltakoMemoryRequest):
            full = await self.read_mem(pretty.address)
            return EltakoMemoryResponse(pretty.row, full[pretty.row]).serialize()

        return await super(ReadaheadMixin, self).base_exchange(request)

# this approach won't work exactly like that, because memory can both be
# written in full or line-wise from PCT; furthermore, there are too many
# timeouts around yet, so there is probably something else fishy.
#
# a better approach would spool all writes and flush them timeout-based, or
# before the next incompatible write comes along.
#
#class WriteDelayer(BusInterface):
#    def __init__(self, *args, **kwargs):
#        super(WriteDelayer, self).__init__(*args, **kwargs)
#        self.spool = []
#
#    async def base_exchange(self, request):
#        pretty = prettify(request)
#        if pretty.org == 0xf2 or pretty.org == 0xf4:
#            print("postponing write operation %s"%request)
#            if pretty.org == 0xf4 and pretty.address == 0x7f:
#                print("Flushing out the write operations now")
#                retries = 3
#                while self.spool:
#                    await asyncio.sleep(0.5)
#                    next_request = self.spool[0]
#                    response = prettify(ESP2Message.parse(await super(WriteDelayer, self).base_exchange(next_request)))
#                    print("%s - %s"%(prettify(next_request), response))
#                    if isinstance(response, EltakoTimeout):
#                        if retries:
#                            retries -= 1
#                            continue
#                        else:
#                            raise Exception("Too many timeouts in write sequence")
#                    else:
#                        self.spool.pop(0)
#                        retries = 3
#                response = await super(WriteDelayer, self).base_exchange(request)
#                print("Flushing complete; you can probably ignore the error the flashing software gave you")
#                return response
#            else:
#                self.spool.append(request)
#
#            return EltakoMessage(pretty.org, pretty.address, pretty.payload, not pretty.is_request).serialize()
#        else:
#            return await super(WriteDelayer, self).base_exchange(request)

class BusCache(BusInterface):
    """Basic store of attributes on the bus that are not expected to change.

    This class takes care of the actual caching logic, but relies on subclasss
    to provide storage.

    The whole locking area is handled as follows: As long as the bus is not
    locked (and it is assumed that the bus is not locked initially), no cached
    data is served, and no responses are cached, due to the assumption that bus
    communication is too erratic then. Only when a successful bus lock is
    obtained, caching is started, and cache responses are handed out.
    Subsequent lock (and even unlock) commands are not sent to the bus, but
    served from memory (as the response to an unlock was always observed to be
    the same as to a lock)."""

    def __init__(self, parent):
        self.parent = parent

        self.is_locked = False

    async def base_exchange(self, request):
        pretty = prettify(request)

        if not self.is_locked:
            response = await self.parent.base_exchange(request)

            try:
                pretty_response = EltakoDiscoveryReply.parse(response)
            except ParseError:
                pass
            else:
                if isinstance(pretty, EltakoBusLock) and isinstance(pretty_response, EltakoDiscoveryReply) and pretty_response.address == 0:
                    self.is_locked = True
                    self['fam_reply'] = response

            return response

        if pretty.org == 0xf2:
            # writing prepared -- we better wipe the cache for that
            self.pop(('memory', pretty.address), None)
            for i in range(256):
                self.pop(('read', pretty.address, i), None)

        key = None
        if isinstance(pretty, EltakoBusLock) or isinstance(pretty, EltakoBusUnlock):
            return self['fam_reply']
        if isinstance(pretty, EltakoDiscoveryRequest):
            key = ('discover', pretty.address)
        elif isinstance(pretty, EltakoMemoryRequest):
            key = ('read', pretty.address, pretty.row)

        if key is None: # uncachable
            return await self.parent.base_exchange(request)

        if key not in self:
            try:
                self[key] = await self.parent.base_exchange(request)
            except TimeoutError:
                self[key] = EltakoTimeout().serialize()

        return self[key]

    async def read_mem(self, address):
        key = ('memory', address)
        if key not in self:
            self[key] = await self.parent.read_mem(address)
        return self[key]

class RAMBusCache(dict, BusCache):
    pass

class PickledBusCache(RAMBusCache):
    def __init__(self, parent, filename):
        BusCache.__init__(self, parent)

        self._filename = filename
        if filename.exists():
            self.update(pickle.load(self._filename.open('rb')))

    def __setitem__(self, k, v):
        super(PickledBusCache, self).__setitem__(k, v)

        self.__save()

    def pop(self, *args, **kwargs):
        result = super(PickledBusCache, self).pop(*args, **kwargs)
        self.__save()
        return result

    # FIXME implement all dict methods with a __save

    def __save(self):
        tmpname = self._filename.with_suffix(".tmp")
        with tmpname.open('wb') as f:
            pickle.dump(dict(self), f)
        tmpname.rename(self._filename)

class ReadaheadPickledBusCache(ReadaheadMixin, PickledBusCache):
    pass


def prettify(message):
    """Given a ESP2Message, try parsing this as all the known message classes
    and return the parsing result if it matches.

    Only use this for displaying messages during debugging; when driving your
    application logic, you should have a good idea of which messages you'd
    expect, and try to $CLASS.parse() what's coming in. If you rely on
    prettify() to hand you the class you expect, later changes to the list of
    supported messages might give you a subtype or something else
    unexpected."""
    classes = [EltakoBusLock, EltakoBusUnlock, EltakoDiscoveryRequest,
            EltakoDiscoveryReply, EltakoMemoryRequest, EltakoMemoryResponse,
            EltakoTimeout, EltakoPoll, EltakoMessage]

    for c in classes:
        try: return c.parse(message.serialize())
        except ParseError: pass

    return message

class ESP2Message:
    """A basic message in EnOcean Serial Protocol 2 serialization. The only
    constraint to this class is that the message has the right length, the
    SYNC_BYTEs are present and that the checksum matches. Everything else is
    left to further telegram formats.

    The .org property exposes the ORG byte present in most telegram formats,
    but does not make any assertions on its meaning.

    Subclasses of this implement the same interface (.parse()), but typically
    store the parsed data internally. Their constructors differ because they
    take a more meaningful version of the message's data.
    """
    def __init__(self, body):
        self.body = body

    def serialize(self):
        return b"\xa5\x5a" + self.body + bytes([sum(self.body) % 256])

    @property
    def org(self):
        return self.body[1]

    @classmethod
    def parse(cls, data):
        if data[:2] != b"\xa5\x5a":
            raise ParseError("No preamble found")
        if len(data) != 14:
            raise ParseError("Invalid message length")

        body = data[2:13]
        if sum(body) % 256 != data[13]:
            raise ParseError("Checksum mismatch")

        return ESP2Message(body)

    def __repr__(self):
        return "<%s %r>"%(type(self).__name__, b2a(self.body))

class EltakoMessage(ESP2Message):
    """A control message of the Eltako bus.

    Note that these messages are proprietary to Eltako, and use the RMT and TCT
    (Receive Message Telegram, Transmit Control Telegram) h_seq values of the
    ESP2 protocol.

    This library will still try to interpret RMT/TCT telegrams as EltakoMessage
    objects because it's the only (known) use of those.

    The ORG field is used to disambiguate more detailed command types."""

    org = None # an instance attribute, no longer a property as in ESP2Message

    def __init__(self, org, address, payload=b"\0\0\0\0\0\0\0\0", is_request=True):
        self.org = org
        self.address = address
        self.payload = payload
        self.is_request = is_request

    body = property(lambda self: bytes((((5 if self.is_request else 4) << 5) + 11, self.org, *self.payload, self.address)))

    @classmethod
    def parse(cls, data):
        esp2message = super().parse(data)
        try:
            is_request = {(5 << 5) + 11: True, (4 << 5) + 11: False}[esp2message.body[0]]
        except KeyError:
            raise ParseError("Code is neither TCT nor RMT")
        org = esp2message.body[1]
        address = esp2message.body[10]
        payload = esp2message.body[2:10]
        return EltakoMessage(org, address, payload, is_request)

    def __repr__(self):
        return "<%s %s ORG %02x ADDR %02x, %s>"%(type(self).__name__, ["Response", "Request"][self.is_request], self.org, self.address, b2a(self.payload))

class EltakoStaticMessage(EltakoMessage):
    """Base class for any kind of message that has no variance in it at all"""
    def __init__(self):
        pass

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                eltakomessage.payload != cls.payload or eltakomessage.address != cls.address:
            raise ParseError("This is not an %s"%(cls.__name__,))
        return cls()

    def __repr__(self):
        return "<%s>"%type(self).__name__

class EltakoBusLock(EltakoStaticMessage):
    """A request to lock the bus (turn on the green LEDs, make senders of
    unsolicited messages like the FTS14 stop sending).

    If there is a FAM on the bus and the bus is already locked, it will respond
    with a DiscoveryReply (?; TBD: Verify the type of the response)."""
    org = 0xff
    is_request = True
    address = 0xff
    payload = b"\0\0\0\0\0\0\0\0"

class EltakoBusUnlock(EltakoStaticMessage):
    """A request to unlock the bus (reverse the effects of EltakoBusLock).

    If there is a FAM on the bus and the bus was locked, it will respond with a
    DiscoveryReply (?; TBD: Verify the type of the response)."""
    org = 0xff
    is_request = True
    address = 0x00
    payload = b"\0\0\0\0\0\0\0\0"

class _EltakoAddressOnlyMessage(EltakoMessage):
    """Base class for any kind of message with static data and varying
    address"""

    def __init__(self, address):
        self.address = address

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                eltakomessage.payload != cls.payload:
            raise ParseError("This is not an EltakoDiscoveryRequest")
        return cls(eltakomessage.address)

    def __repr__(self):
        return "<%s to %s>" % (type(self).__name__, self.address)

class EltakoPoll(_EltakoAddressOnlyMessage):
    """Ask a bus participant to send its queued messages"""
    org = 0xfc
    is_request = True
    payload = b"\0\0\0\0\0\0\0\0"

class EltakoDiscoveryRequest(_EltakoAddressOnlyMessage):
    """Solicit a DiscoveryReply from a bus participant that has a given bus
    address. Any device in bus address learning mode will take up any
    EltakoDiscoveryRequest, answer it and assign this as its new bus
    address."""
    org = 0xf0
    is_request = True
    payload = b"\0\0\0\0\0\0\0\0"

class EltakoDiscoveryReply(EltakoMessage):
    """A data summary reporting the key parameters of a device, including its
    address, the number of slots it uses on the address bus, its memory size
    and its model number."""
    org = 0xf0
    is_request = False
    address = 0

    def __init__(self, reported_address, reported_size, memory_size, model, is_fam):
        self.reported_address = reported_address
        self.reported_size = reported_size
        self.memory_size = memory_size
        self.model = model
        self.is_fam = is_fam

    payload = property(lambda self: bytes((self.reported_address, self.reported_size, self.memory_size, 0x00 if self.is_fam else 0x08)) + self.model)

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or eltakomessage.address != cls.address:
            raise ParseError("This is not an EltakoDiscoveryReply")
        try:
            is_fam = {0x00: True, 0x08: False}[eltakomessage.payload[3]]
        except KeyError:
            raise ParseError("Assumed fixed part 00 or 08 not present (found %02x)"%eltakomessage.payload[3])
        reported_address = eltakomessage.payload[0]
        reported_size = eltakomessage.payload[1]
        memory_size = eltakomessage.payload[2]
        model = eltakomessage.payload[4:8]
        return EltakoDiscoveryReply(reported_address, reported_size, memory_size, model, is_fam)

    def __repr__(self):
        return "<%s address %d size %d, model %s%s>"%(type(self).__name__, self.reported_address, self.reported_size, b2a(self.model), " (FAM)" if self.is_fam else "")

class EltakoMemoryRequest(EltakoMessage):
    org = 0xf1
    is_request = True

    @property
    def payload(self):
        return bytes([0] * 7 + [self.row])

    def __init__(self, address, row):
        self.address = address
        self.row = row

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request or \
                any(eltakomessage.payload[:7]):
            raise ParseError("This is not an EltakoMemoryRequest")
        return cls(eltakomessage.address, eltakomessage.payload[7])

    def __repr__(self):
        return "<%s address %d row %d>"%(type(self).__name__, self.address, self.row)

class EltakoMemoryResponse(EltakoMessage):
    org = 0xf1
    is_request = False

    @property
    def payload(self):
        return self.value

    @property
    def address(self):
        return self.row

    def __init__(self, row, value):
        self.row = row
        self.value = value

    @classmethod
    def parse(cls, data):
        eltakomessage = super().parse(data)
        if eltakomessage.org != cls.org or eltakomessage.is_request != cls.is_request:
            raise ParseError("This is not an EltakoMemoryResponse")
        return cls(eltakomessage.address, eltakomessage.payload)

    def __repr__(self):
        return "<%s row %d value %s>"%(type(self).__name__, self.row, b2a(self.value))

class EltakoTimeout(EltakoStaticMessage):
    org = 0xf8
    is_request = False
    payload = b"\0\0\0\0\0\0\0\0"
    address = 0



class BusObject:
    def __init__(self, response, *, bus=None):
        self.discovery_response = response
        if self.discovery_response.reported_size != self.size:
            # won't happen with the default size implementation, but another class may give a constant here
            raise ValueError("Unexpected size (got %d, expected %d for %r)"%(self.discovery_response.reported_size, self.size, self))
        self.bus = bus

    @property
    def version(self):
        high, low = self.discovery_response.model[2:4]
        return (high >> 4, high & 0xf, low >> 4, low & 0xf0)

    address = property(lambda self: self.discovery_response.reported_address)
    size = property(lambda self: self.discovery_response.reported_size)

    def __repr__(self):
        classname = type(self).__name__
        if not hasattr(self, 'discovery_name'):
            classname += " (%02x %02x)"%(self.discovery_response.model[0], self.discovery_response.model[1])
        return "<%s at %d size %d version %s>"%(classname, self.address, self.size, self.version)

    async def read_mem(self):
        """Simple bound wrapper for bus.read_mem"""
        return await self.bus.read_mem(self.address)

    async def read_mem_line(self, line):
        response = await self.bus.exchange(EltakoMemoryRequest(self.address, line), EltakoMemoryResponse)
        return response.value

    async def write_mem_line(self, row, value):
        select_response = await self.bus.exchange(EltakoMessage(0xf2, self.address))
        if select_response.org != 0xf2:
            raise WriteError("Device selection failed; expected 0xf2, got %r"%select_response)

        write_response = await self.bus.exchange(EltakoMessage(0xf4, row, value))
        if write_response.org != 0xf4:
            raise WriteError("Write failed; expected 0xf4, got %r"%write_response)

    async def show_off(self):
        print("Identifying on the bus")
        await self.bus.exchange(EltakoMessage(0xfd, self.address))
        await asyncio.sleep(3)

    @classmethod
    def annotate_memory(cls, mem):
        return {}

class FUD14(BusObject):
    size = 1
    discovery_name = bytes((0x04, 0x04))

    async def show_off(self):
        await super().show_off()

        print("Querying dimmer state")
        response = await(self.bus.exchange(EltakoMessage(0xfe, self.address), EltakoMessage))
        # parsing A5-38-08 style data
        assert response.org == 0x07
        # parsing is a little funny here because while it's an RMT, it
        # still behaves like a message with regular payload
        assert response.payload[0] == 0x02
        print("Dimmer value is %d"%response.payload[1]) # it's funny -- the FUD usually reports 'absolute', but then still has its db2 ranging from 0 to 100 instead of 255
        print("Ramping speed is %ds to 100%%"%response.payload[2])
        print("Bits are %s, %s, %s"%(
            ["absolute", "relative"][response.payload[3] & (1 << 2)],
            ["don't store", "store"][response.payload[3] & (1 << 1)],
            ["switch off", "switch on"][response.payload[3] & (1 << 0)],
            ))

        print("Reading out input programming")
        for memory_id in range(12, 128):
            line = await self.read_mem_line(memory_id)
            sender = line[:4]
            function = line[5]
            if function == 32:
                dimming = min(random.randint(0, 10) ** 2 + random.randint(0, 3), 100)
                print("I'e found a programmed universal dimmer state input, sending value %d"%dimming)
                print(await(self.bus.exchange(ESP2Message(b"\x0b\x07\x02" + bytes([dimming]) + b"\0\x09" + sender + b"\0"), EltakoTimeout)))

    @classmethod
    def annotate_memory(cls, mem):
        return {
                8: MemoryFileStartOfSectionComment("function group 1"),
                9: MemoryFileStartOfSectionComment("function group 2"),
                12: [
                    MemoryFileStartOfSectionComment("function group 4"),
                    MemoryFileNibbleExplanationComment(
                         "AD DR ES S, KY FN SP %%",
                         "key (5 = left, 6 = right), function (eg. 32 = A5-38-08), speed, percent"),
                    ],
                }


class FSR14(BusObject):
    async def show_off(self):
        await super().show_off()

        want_switch_channel = random.randint(0, self.size - 1)

        for subchannel in range(self.size):
            print("Querying state of channel %d"%subchannel)
            response = await(self.bus.exchange(EltakoMessage(0xfe, self.address + subchannel), EltakoMessage))
            # this looks rps-like (
            assert response.payload[4:] == bytes((0, 0, 0, self.address + subchannel))
            assert response.org == 0x05
            # even though it's an RMT and should thus behave like an
            # EltakoMessage, this has regular enocean semantics, so what we
            # actually mean with addr is status
            assert response.address == 0x30
            # and this is db1..3
            assert not any(response.payload[1:4])
            state = {0x50: 0, 0x70: 1}[response.payload[0]]
            print("Channel is at %d"%state)

            if subchannel == want_switch_channel:
                want_switch_currentstate = state

        print("Trying to switch subchannel %d, reading out input programming"%want_switch_channel)
        for memory_id in range(12, 128):
            line = await self.read_mem_line(memory_id)
            sender = line[:4]
            function = line[5]
            key = line[4]
            channels = line[6]
            db0_for_switching = { # (function, key) to (off, on)
                    (3, 6): (0x70, 0x50), # directional buttons enable on down, right keys
                    (3, 5): (0x30, 0x10), # directional buttons enable on down, left keys
                    (2, 6): (0x50, 0x70), # directional buttons enable on up, right keys
                    (2, 5): (0x10, 0x30), # directional buttons enable on up, left keys
                    }
            db0 = db0_for_switching.get((function, key), (None, None))[not want_switch_currentstate]
            if db0 is not None and channels == (1 << want_switch_channel):
                print("Found suitable programming for direct switching of subchannel in memory row %d from %d to %d"%(memory_id, want_switch_currentstate, not want_switch_currentstate))
                print(await self.bus.exchange(ESP2Message(b"\x0b\x05" + bytes([db0]) + b"\0\0\0" + sender + b"\30")))
                break
        else:
            print("No suitable programming found for switching the subchannel")

    @classmethod
    def annotate_memory(cls, mem):
        return {
                2: MemoryFileNibbleExplanationComment("R0 R1 R2 R3", "(bool)Rn = 'restore channel n on power-up"),
                8: MemoryFileStartOfSectionComment("function group 1"),
                12: [
                    MemoryFileStartOfSectionComment("function group 2"),
                    MemoryFileNibbleExplanationComment(
                         "AD DR ES S, KY FN CH 00",
                         "key (5 = left, 6 = right), function (3 = bottom enable, 2 = upper enable), ch = affected channels as bits"),
                    ],
                }

class FSR14_1x(FSR14):
    discovery_name = bytes((0x04, 0x01))
    size = 1

class FSR14_2x(FSR14):
    discovery_name = bytes((0x04, 0x02))
    size = 2

class FSR14_4x(FSR14):
    discovery_name = bytes((0x04, 0x01))
    size = 4

class F4SR14_LED(BusObject):
    discovery_name = bytes((0x04, 0x09))
    size = 4

class F3Z14D(BusObject):
    discovery_name = bytes((0x04, 0x67))
    size = 3

class FMZ14(BusObject):
    discovery_name = bytes((0x04, 0x0e))
    size = 1

class FWG14MS(BusObject):
    discovery_name = bytes((0x04, 0x1a))
    size = 1

class FSU14(BusObject):
    discovery_name = bytes((0x07, 0x14))
    size = 8
    async def show_off(self):
        await super().show_off()

        hour = random.randint(0, 23)
        minutes = random.randint(0, 59)
        print("Setting clock to %02d:%02d"%(hour, minutes))
        await self.write_mem_line(0x5d, b"\x16\x01\x01\x08" + bytes((((hour // 10) << 4) + (hour % 10), ((minutes // 10) << 4) + (minutes % 10))) + b"\x00\x01")

        await asyncio.sleep(3)

class FMSR14(BusObject):
    discovery_name = bytes((0x05, 0x15))
    size = 5

class FWZ14_65A(BusObject):
    discovery_name = bytes((0x04, 0x66))
    size = 1

    @classmethod
    def annotate_memory(cls, mem):
        return {
                1: MemoryFileNibbleExplanationComment(".. .. .. .. ..  SUM kWh", "accumulated counter value as sent in DT=0 DIV=0 telegram"),
                5: MemoryFileNibbleExplanationComment("S0 S1 S2 S3 .. .. .. ..", "Serial number as sent in DT=1 DIV=3 TI=8 messages (once as with DB3..1 = S1 S0 00, once as S3 S2 01)")
                }

known_objects = [FUD14, FSR14_1x, FSR14_2x, FSR14_4x, F4SR14_LED, F3Z14D, FMZ14, FWG14MS, FSU14, FMSR14, FWZ14_65A]
# sorted so the first match of (discovery name is a prefix, size matches) can be used
sorted_known_objects = sorted(known_objects, key=lambda o: len(o.discovery_name) + 0.5 * (o.size is not None), reverse=True)

async def create_busobject(bus, id):
    response = await bus.exchange(EltakoMessage(org=0xf0, address=id), EltakoDiscoveryReply)

    assert id == response.reported_address

    for o in sorted_known_objects:
        if response.model.startswith(o.discovery_name) and (o.size is None or o.size == response.reported_size):
            return o(response, bus=bus)
    else:
        return BusObject(response, bus=bus)

async def enumerate_bus(bus, *, limit_ids=None):
    """Search the bus for devices, yield bus objects for every match"""

    if limit_ids is None:
        limit_ids = range(1, 255)

    for i in limit_ids:
        try:
            yield await create_busobject(bus, i)
        except TimeoutError:
            continue


class MemoryFile(defaultdict):
    """In-memory representation of a YAML file suitable for storing, editing,
    verifying and flashing device memory contents

    The YAML file is a dict of dicts, mapping bus ids and memory lines (or
    memory ranges for compression) to binascii hexdumps. The MemoryFile behaves
    the same, but with binary strings as values."""

    def __init__(self):
        defaultdict.__init__(self, lambda: {})
        self.comments = {}
        self.linecomments = {}

    @classmethod
    def load(cls, f):
        result = cls()
        fromfile = yaml.load(f)
        result = cls()
        for k1, v1 in fromfile.items():
            for k2, v2 in v1.items():
                if isinstance(k2, int):
                    k2 = [k2]
                else:
                    start, end = k2.split('-', 1)
                    start, end = int(start), int(end)
                    k2 = range(start, end + 1)
                for k2entry in k2:
                    result[k1][k2entry] = binascii.unhexlify(v2.replace(' ', ''))
        return result

    def store(self, f):
        for_file = {}
        linecomments_for_file = {}
        for k1, v1 in self.items():
            for_file[k1] = dict()
            linecomments_for_file[k1] = dict()
            last_start = None
            last = None
            for k2, v2 in v1.items():
                if last != v2 or k2 in self.linecomments[k1]:
                    if last is not None:
                        # flush
                        if last_start == k2 - 1:
                            last_key = last_start
                        else:
                            last_key = "%d-%d"%(last_start, k2 - 1)
                        for_file[k1][last_key] = last
                        linecomments_for_file[k1][last_key] = self.linecomments[k1].get(last_start, [])
                    last_start = k2
                last = v2
            # flush end
            if last_start == k2:
                last_key = last_start
            else:
                last_key = "%d-%d"%(last_start, k2)
            for_file[k1][last_key] = last
            linecomments_for_file[k1][last_key] = self.linecomments[k1].get(last_start, [])

        # to get "uncompressed" dumps:
        # for_file = self

        for k1, v1 in for_file.items():
            if k1 in self.comments:
                print("%d: # %s"%(k1, self.comments[k1]), file=f)
            else:
                print("%d:"%k1, file=f)

            for k2, v2 in v1.items():
                lc = linecomments_for_file[k1][k2]
                if not isinstance(lc, list):
                    lc = [lc]
                for c in lc:
                    if isinstance(c, MemoryFileStartOfSectionComment):
                        print("    # ------ %s"%c, file=f)
                for c in lc:
                    if isinstance(c, MemoryFileNibbleExplanationComment):
                        print("    #        % -23s -- %s"%c, file=f)
                suffixcomments = " " + ", ".join(str(c) for c in lc if isinstance(c, MemoryFileStateComment))
                print("    % -8s %s%s"%("%s:"%k2, b2a(v2), suffixcomments.rstrip()), file=f)
            print(file=f)

class MemoryFileComment: pass
class MemoryFileStartOfSectionComment(str, MemoryFileComment): pass
class MemoryFileNibbleExplanationComment(namedtuple("_nibbleexp", "nibbles explanation"), MemoryFileComment): pass
class MemoryFileStateComment(str, MemoryFileComment): pass


def buslocked(f):
    """Wraps a coroutine inside a bus locking and (finally) bus unlocking. The
    coroutine must take a bus as its first argument."""
    @functools.wraps(f)
    async def new_f(bus, *args, **kwargs):
        try:
            print("Sending a lock command onto the bus; its reply should tell us whether there's a FAM in the game.")
            await lock_bus(bus)
            return await f(bus, *args, **kwargs)
        finally:
            print("Unlocking the bus again")
            await unlock_bus(bus)
    return new_f

@buslocked
async def enumerate_cmd(bus):
    print("Scanning the bus for devices with addresses...")
    usage_map = [False] * 256
    async for dev in enumerate_bus(bus):
        print("Discovered: %s"%dev)
        usage_map[dev.address:dev.address+dev.size] = [True] * dev.size

    print("Bus scan completed.")

    reported = False
    while True:
        try:
            response = await bus.exchange(EltakoDiscoveryRequest(address=0), EltakoDiscoveryReply)
        except TimeoutError:
            if reported is False:
                print("You may now put a device into LRN mode to automatically assign an address.")
                reported = True
        else:
            print("A device is available in LRN mode (model %s, size %d)."%(b2a(response.model), response.reported_size))
            for i in range(1, 254 - response.reported_size):
                if not any(usage_map[i:i+response.reported_size]):
                    break
            else:
                raise Exception("No suitable free space in usage map")

            usage_map[i:i+response.reported_size] = [True] * response.reported_size
            response = await bus.exchange(EltakoMessage(org=0xf8, address=i), EltakoDiscoveryReply)
            if response.reported_address == 0:
                print("Assigning may not have worked, marking area as dirty and trying again...")
                continue
            assert response.reported_address == i, "Assigning bus number %d resulted in response %r"%(i, response)
            print("The device was assigned bus address %d. You may now put a further device into LRN mode."%i)


@buslocked
async def preread(bus):
    """Given a partial'd exchange function, read once through all addresses and all their memory content"""

    for i in range(256):
        try:
            r = await bus.exchange(EltakoDiscoveryRequest(address=i), EltakoDiscoveryReply)
        except TimeoutError:
            continue

        print("Scanning memory of %d"%i)
        await bus.read_mem(i)

async def run_fakefam(bus, reader, writer, conn_made: Optional[asyncio.Future]=None, conn_end: Optional[asyncio.Future]=None):
    if conn_made:
        conn_made.set_result(None)
    buffered = b""

    while True:
        try:
            buffered += await reader.readexactly(14 - len(buffered))
        except asyncio.streams.IncompleteReadError:
            break
        while len(buffered) >= 14:
            try:
                parsed = ESP2Message.parse(buffered[:14])
            except ParseError:
                buffered = buffered[1:]
            else:
                buffered = buffered[14:]

                start = time.time()
                response = await bus.exchange(parsed, ESP2Message)
                end = time.time()
                print(prettify(parsed), "(%.3fs)"%(end - start), prettify(response))
                writer.write(response.serialize())

    if conn_end:
        conn_end.set_result(None)

async def fakefam(bus, serverdevice):
    # serverdevice will be tested to be a character device, and otherwise
    # opened as a unix or tcp socket depending on whether it contains slashes
    # or colons.
    loop = asyncio.get_event_loop()

    try:
        # reader, writer = await serial_asyncio.open_serial_connection(serverdevice, baudrate=57600, loop=loop)
        # the above should work as well -- this is a workaround for not-sure-what
        reader = asyncio.StreamReader()
        protocol = asyncio.StreamReaderProtocol(reader)
        transport, _ = await serial_asyncio.create_serial_connection(loop, lambda: protocol, serverdevice, baudrate=57600)
        writer = asyncio.StreamWriter(transport, protocol, reader, loop)
        await run_fakefam(bus, reader, writer)
    except serial.serialutil.SerialException:
        pass
    else:
        def read():
            return os.read(s.fileno(), 1024)
        write = s.write

        q = asyncio.Queue(loop=loop)
        loop.add_reader(s.fileno(), lambda: q.put_nowait(read()))
        return

    conn_end = asyncio.Future()
    if '/' in serverdevice or not ':' in serverdevice:
        conn_made = asyncio.Future()
        await asyncio.start_unix_server(functools.partial(run_fakefam, bus, conn_made=conn_made, conn_end=conn_end), serverdevice, loop=loop)
        await conn_made
        os.unlink(serverdevice)
    else:
        # note that this could run several connections at the same time, which is both great and terrifying
        host, port = serverdevice.split(':', 1)
        await asyncio.start_server(functools.partial(run_fakefam, bus, conn_end=conn_end), host, int(port), loop=loop)
    await conn_end

async def send_raw(bus, data):
    print(prettify(await bus.exchange(ESP2Message(bytes(data)), ESP2Message)))

async def lock_bus(bus):
    for i in range(10):
        try:
            response = await bus.exchange(EltakoBusLock(), EltakoMessage)
        except TimeoutError:
            continue
        if response.org == 0xf0:
            print("FAM acknowledged lock after %d try(s)."%(i+1))
            return
        else:
            print("Unexpected message: %s"%response)
    print("Sent some requests, but no acknowledgement from FAM")

async def unlock_bus(bus):
    # probably we don't need to repeat that at all
    for i in range(5):
        response = await bus.exchange(EltakoBusUnlock(), EltakoMessage)
        if response.org == 0xf0:
            print("FAM acknowledged return to regular operation (%s)"%response)
            return
        if response.org != 0xf8:
            print("Unexpected response %r"%response)
    print("Sent some requests, but no acknowledgement from FAM; maybe we're bus master ourselves")

@buslocked
async def show_off(bus, search_term=""):
    devices = []

    print("Scanning the bus for devices with addresses...")

    try:
        search_term_int = int(search_term)
    except ValueError:
        scan = range(1, 255)
    else:
        scan = [search_term_int]
        search_term = ""

    async for dev in enumerate_bus(bus, limit_ids=scan):
        if not search_term or search_term.lower() in repr(dev).lower():
            devices.append(dev)
            print("Discovered %r"%dev)
        else:
            print("Ignoring discovered %s"%dev)

    if not devices:
        print("No matching devices found.")
        print(await bus.exchange(EltakoMessage(0xff, 0x00)))
        return

    print("Now let's see what the devices can do:")

    while True:
        await asyncio.sleep(2)
        for d in devices:
            print("Playing with %r"%d)
            await d.show_off()

            while hasattr(bus, "received") and not bus.received.empty():
                print("Meanwhile, something else happened on the bus as well: %s" % bus.received.get_nowait())

@buslocked
async def dump(bus, outfile):
    memfile = MemoryFile()

    async for dev in enumerate_bus(bus):
        mem = await dev.read_mem()
        memfile[dev.address] = dict(enumerate(mem))

        memfile.comments[dev.address] = repr(dev)
        memfile.linecomments[dev.address] = dev.annotate_memory(mem)

    with outfile.open('w') as f:
        memfile.store(f)

@buslocked
async def verify(bus, infile):
    memfile = MemoryFile.load(infile.open())

    delta = 0

    for devno, lines in memfile.items():
        device = await create_busobject(bus, devno)

        current_memory = await device.read_mem()
        for (row, value) in lines.items():
            if current_memory[row] != value:
                delta += 1
                print("Difference in device %s line %d:"%(device, row))
                print("device:", b2a(current_memory[row]))
                print("file:  ", b2a(value))

    if delta:
        sys.exit(1)

@buslocked
async def reprogram(bus, infile):
    memfile = MemoryFile.load(infile.open())

    delta = 0
    seen = 0

    for devno, lines in memfile.items():
        device = await create_busobject(bus, devno)

        current_memory = await device.read_mem()
        for (row, value) in lines.items():
            if current_memory[row] == value:
                seen += 1
            else:
                delta += 1
                await device.write_mem_line(row, value)

    print("Unmodified lines: %d. Modified lines: %d"%(seen, delta))

async def listen(bus, ensure_unlocked):
    if ensure_unlocked:
        await lock_bus(bus)
        await unlock_bus(bus)

    seen_someone_polling = False

    while True:
        msg = await bus.received.get()
        msg = prettify(msg)

        if isinstance(msg, EltakoPoll):
            if not seen_someone_polling:
                seen_someone_polling = True
                print("There is a device on the bus that polls for messages.")
            continue

        print(msg)

async def automode(bus):
    for i in range(20):
        try:
            response = await bus.exchange(EltakoBusLock(), EltakoDiscoveryReply)
            if not response.is_fam:
                # typically happens when FAM is just scanning and we get one of
                # its replies back rather than its "OK I'm locked"
                continue
        except TimeoutError:
            continue
        print("FAM acknowledged lock after %d try(s); data: %s" % (i+1, response))
        found_fam = True
        break
    else:
        print("No FAM present on the bus")
        found_fam = False

    # Ignore what was seen so far
    while not bus.received.empty():
        bus.received.get_nowait()

    try:
        response = await bus.exchange(EltakoBusUnlock(), EltakoDiscoveryReply)
    except TimeoutError:
        if found_fam:
            print("Confused: FAM did not acknowledge lock release")
            return
    else:
        if not found_fam:
            print("Confused: FAM replied to unlock but not to lock request")

    discovery_seen_for = {}
    spooled_scan_results = {}

    # find out whether it starts scanning, and/or polling
    async def update_discovery():
        while True:
            msg = await bus.received.get()
            msg = prettify(msg)

            if isinstance(msg, EltakoDiscoveryRequest):
                print("Someone's asking for", msg.address)
                discovery_seen_for[msg.address] = True
                continue

            if isinstance(msg, EltakoDiscoveryReply):
                print("Acknowledging that there's a device:", msg.address, msg)
                spooled_scan_results[msg.reported_address] = msg
                continue

            if isinstance(msg, EltakoPoll):
                print("Polling already started, not expecting any more discovery")
                break

    update_process = asyncio.ensure_future(update_discovery())
    resultcount = -1
    timeout = 3
    while True:
        oldresultcount = resultcount
        resultcount = len(discovery_seen_for) + len(spooled_scan_results)
        if resultcount == oldresultcount:
            # stagnation
            break
        # Wait up to 3 seconds for scanning to get something on, or until it's obviously concluded
        try:
            await asyncio.wait_for(asyncio.shield(update_process), timeout)
        except asyncio.TimeoutError:
            # 3 seconds for the first activity to be on the safe side, but then
            # it should finish swiftly.
            timeout = 1
            continue
        else:
            break
    # This does lose any messages that showed up after the discovery phase, but
    # I'm currently not really interested in that.
    update_process.cancel()

    scancount = len(discovery_seen_for) + sum(s.reported_size - 1 for s in spooled_scan_results.values())

    if scancount == 0:
        print("Nobody is scanning")
    elif scancount == 127:
        print("Bus was scanned in full")

    # NEXT STEP: dissect FAM positions
    # 2, 3, 4: FAM found, full scan, and polling starts
    # 5: FAM found, nobody scanning
    # other modes? read FAM memory to find position?

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--rawuri", help="URI at which a raw ESP2 resource is exposed")
    p.add_argument("--eltakobus", help="File at which a RS485 Eltako bus can be opened")
    p.add_argument("--cache", help="Store cachable responses locally", action='store_true')
    p.add_argument("--cachefile", help="File to cache responses at", type=Path)
    p.add_argument("--preread", help="Enumerate bus and read devices' memory before executing the command", action='store_true')
    subp = p.add_subparsers(metavar="command", dest="command")

    p_enumerate = subp.add_parser("enumerate", help="Explore the bus")
    p_fakefam = subp.add_parser("fakefam", help="Act like a FAM14")
    p_fakefam.add_argument("device", help="Serial device to listen on for bus commands")

    p_send4bs = subp.add_parser("send_raw", help="Send a raw telegram (h_seq/len, org, data, id, status), with bytes as individual hex arguments")
    base16 = functools.partial(int, base=16)
    p_send4bs.add_argument("data", type=base16, nargs=11)

    p_eval = subp.add_parser("eval", help="Display the response to a single message object passed as a Python expression")
    p_eval.add_argument("expr")

    subp.add_parser("lock_bus", help="Lock the bus")
    subp.add_parser("unlock_bus", help="Release the FAM to normal operation")

    p_showoff = subp.add_parser("show_off", help="Run a demo of what is currently known of the bus")
    p_showoff.add_argument("searchterm", nargs="?", default="", help="Bus address or type name to focus on")

    # FIXME allow filtering
    p_dump = subp.add_parser("dump", help="Dump the memory contents of the devices on the bus into a given file")
    p_dump.add_argument("filename", help="File to store the dump in (default: %(default)s)", default="bus.yaml", type=Path, nargs='?')

    p_verify = subp.add_parser("verify", help="Compare the memory contents of the devices with a given dump")
    p_verify.add_argument("filename", help="File to read the dump from (default: %(default)s)", default="bus.yaml", type=Path, nargs='?')

    p_reprogram = subp.add_parser("reprogram", help="Set the memory contents of the devices with a given dump")
    p_reprogram.add_argument("filename", help="File to read the dump from (default: %(default)s)", default="bus.yaml", type=Path, nargs='?')

    p_listen = subp.add_parser("listen", help="Display any messages sent on the bus without sending (not supported on all backends)")
    p_listen.add_argument("--ensure-unlocked", help="Lock and unlock the bus before listening, thus forcing a FAM to re-enumerate", action='store_true')

    subp.add_parser("automode", help="Determine what's on the bus (including FAM mode), report, and listen")

    opts = p.parse_args()

    if opts.command is None:
        raise p.error("A command is required.")

    if opts.rawuri is not None and opts.eltakobus is not None:
        raise p.error("--rawuri and --eltakobus are conflicting options.")
    if opts.rawuri is None and opts.eltakobus is None:
        raise p.error("Autodiscovery is not yet implemented, please give --rawuri argument or an --eltakobus.")

    loop = asyncio.get_event_loop()

    if opts.rawuri:
        context = loop.run_until_complete(aiocoap.Context.create_client_context())
        bus = CoAPInterface(context, opts.rawuri)
    if opts.eltakobus:
        bus_ready = asyncio.Future()
        bus = RS485SerialInterface(opts.eltakobus)
        asyncio.ensure_future(bus.run(loop, conn_made=bus_ready), loop=loop)
        loop.run_until_complete(bus_ready)

    if opts.cache:
        cachefile = opts.cachefile or Path(xdg.BaseDirectory.save_cache_path("eltakotool")) / opts.rawuri.replace('/', '-')
        bus = ReadaheadPickledBusCache(bus, cachefile)

    if opts.preread:
        if not opts.cache:
            print("Warning: Without caching, prereading is not much good.")
        print("Prereading bus...")
        loop.run_until_complete(preread(bus))
        print("done.")

    if opts.command == "enumerate":
        maintask = enumerate_cmd(bus)
    elif opts.command == "fakefam":
        maintask = fakefam(bus, opts.device)
    elif opts.command == "send_raw":
        maintask = send_raw(bus, opts.data)
    elif opts.command == "eval":
        maintask = bus.exchange(eval(opts.expr))
    elif opts.command == "lock_bus":
        maintask = lock_bus(bus)
    elif opts.command == "unlock_bus":
        maintask = unlock_bus(bus)
    elif opts.command == "show_off":
        maintask = show_off(bus, opts.searchterm)
    elif opts.command == 'dump':
        maintask = dump(bus, opts.filename)
    elif opts.command == 'verify':
        if opts.cache:
            print("Warning: verification with cache enabled can be misleading", file=sys.stderr)
        maintask = verify(bus, opts.filename)
    elif opts.command == 'reprogram':
        maintask = reprogram(bus, opts.filename)
    elif opts.command == 'listen':
        maintask = listen(bus, opts.ensure_unlocked)
    elif opts.command == 'automode':
        maintask = automode(bus)
    else:
        raise RuntimeError("Additional command declared but not implemented.")

    maintask = asyncio.Task(maintask)

    try:
        result = loop.run_until_complete(maintask)
    except KeyboardInterrupt as e:
        print("Received keyboard interrupt, cancelling", file=sys.stderr)
        maintask.cancel()
        try:
            loop.run_until_complete(maintask)
        except asyncio.CancelledError:
            pass
        sys.exit(1)

    if result is not None:
        print(result)

if __name__ == "__main__":
    main()
